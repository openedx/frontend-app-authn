import { useEffect, useMemo, useState } from 'react';

import { getConfig } from '@edx/frontend-platform';
import { sendPageEvent, sendTrackEvent } from '@edx/frontend-platform/analytics';
import { useIntl } from '@edx/frontend-platform/i18n';
import { Form, Spinner, StatefulButton } from '@openedx/paragon';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import { Helmet } from 'react-helmet';
import Skeleton from 'react-loading-skeleton';

import ConfigurableRegistrationForm from './components/ConfigurableRegistrationForm';
import RegistrationFailure from './components/RegistrationFailure';
import { useRegistration } from './data/apiHook';
import {
  FORM_SUBMISSION_ERROR,
  TPA_AUTHENTICATION_FAILURE,
} from './data/constants';
import {
  isFormValid, prepareRegistrationPayload,
} from './data/utils';
import messages from './messages';
import { EmailField, NameField, UsernameField } from './RegistrationFields';
import {
  InstitutionLogistration,
  PasswordField,
  RedirectLogistration,
  ThirdPartyAuthAlert,
} from '../common-components';
import { useThirdPartyAuthContext } from '../common-components/components/ThirdPartyAuthContext';
import { useThirdPartyAuthHook } from '../common-components/data/apiHook';
import EnterpriseSSO from '../common-components/EnterpriseSSO';
import ThirdPartyAuth from '../common-components/ThirdPartyAuth';
import {
  COMPLETE_STATE, DEFAULT_STATE, PENDING_STATE, REGISTER_PAGE,
} from '../data/constants';
import {
  getAllPossibleQueryParams, getTpaHint, getTpaProvider, isHostAvailableInQueryParams, setCookie,
} from '../data/utils';
import { useRegisterContext } from './components/RegisterContext';
/**
 * Inner Registration Page component that uses the context
 */
const RegistrationPage = (props) => {
  const { formatMessage } = useIntl();
  // const dispatch = useDispatch();
  const {
    fieldDescriptions,
    optionalFields,
    thirdPartyAuthApiStatus,
    thirdPartyAuthContext,
    setThirdPartyAuthContextBegin,
    setThirdPartyAuthContextSuccess,
    setThirdPartyAuthContextFailure,
  } = useThirdPartyAuthContext();

  const {
    autoSubmitRegForm,
    currentProvider,
    finishAuthUrl,
    pipelineUserDetails,
    providers,
    secondaryProviders,
    errorMessage: thirdPartyAuthErrorMessage,
  } = thirdPartyAuthContext;

  const {
    clearRegistrationBackendError,
    registrationFormData,
    registrationResult,
    registrationError,
    setUserPipelineDataLoaded,
    setEmailSuggestionContext,
    updateRegistrationFormData,
    setRegistrationResult,
    setRegistrationError,
    userPipelineDataLoaded,
    backendValidations,
    setBackendCountryCode,
  } = useRegisterContext();

  // Hook for third-party auth API call

  const { mutate: fetchThirdPartyAuth } = useThirdPartyAuthHook();

  const registrationEmbedded = isHostAvailableInQueryParams();
  const platformName = getConfig().SITE_NAME;
  const flags = {
    showConfigurableEdxFields: getConfig().SHOW_CONFIGURABLE_EDX_FIELDS,
    showConfigurableRegistrationFields: getConfig().ENABLE_DYNAMIC_REGISTRATION_FIELDS,
    showMarketingEmailOptInCheckbox: getConfig().MARKETING_EMAILS_OPT_IN,
    autoGeneratedUsernameEnabled: getConfig().ENABLE_AUTO_GENERATED_USERNAME,
  };
  const {
    handleInstitutionLogin,
    institutionLogin,
  } = props;

  const backendRegistrationError = registrationError;
  const registrationMutation = useRegistration({
    onSuccess: (data) => {
      setRegistrationResult(data);
      setRegistrationError({});
    },
    onError: (errorData) => {
      setRegistrationError(errorData);
    },
  });

  const registrationErrorCode = registrationError?.errorCode || backendRegistrationError?.errorCode;
  const submitState = registrationMutation.isPending ? PENDING_STATE : DEFAULT_STATE;
  const queryParams = useMemo(() => getAllPossibleQueryParams(), []);
  const tpaHint = useMemo(() => getTpaHint(), []);
  // Initialize form state from local backedUpFormData
  const backedUpFormData = registrationFormData;
  const [formFields, setFormFields] = useState({ ...backedUpFormData.formFields });
  const [configurableFormFields, setConfigurableFormFields] = useState({ ...backedUpFormData.configurableFormFields });
  const [errors, setErrors] = useState({ ...backedUpFormData.errors });
  const [errorCode, setErrorCode] = useState({ type: '', count: 0 });
  const [formStartTime, setFormStartTime] = useState(null);
  // temporary error state for embedded experience because we don't want to show errors on blur
  const [temporaryErrors, setTemporaryErrors] = useState({ ...backedUpFormData.errors });
  const { cta, host } = queryParams;
  const buttonLabel = cta
    ? formatMessage(messages['create.account.cta.button'], { label: cta })
    : formatMessage(messages['create.account.for.free.button']);

  /**
   * Set the userPipelineDetails data in formFields for only first time
   */
  useEffect(() => {
    if (!userPipelineDataLoaded && thirdPartyAuthApiStatus === COMPLETE_STATE) {
      if (thirdPartyAuthErrorMessage) {
        setErrorCode(prevState => ({ type: TPA_AUTHENTICATION_FAILURE, count: prevState.count + 1 }));
      }
      if (pipelineUserDetails && Object.keys(pipelineUserDetails).length !== 0) {
        const { name = '', username = '', email = '' } = pipelineUserDetails;
        setFormFields(prevState => ({
          ...prevState, name, username, email,
        }));
        setUserPipelineDataLoaded(true);
      }
    }
  }, [ // eslint-disable-line react-hooks/exhaustive-deps
    thirdPartyAuthApiStatus,
    thirdPartyAuthErrorMessage,
    pipelineUserDetails,
    userPipelineDataLoaded,
  ]);

  useEffect(() => {
    if (!formStartTime) {
      sendPageEvent('login_and_registration', 'register');
      const payload = { ...queryParams, is_register_page: true };
      if (tpaHint) {
        payload.tpa_hint = tpaHint;
      }
      setThirdPartyAuthContextBegin();
      fetchThirdPartyAuth(payload, {
        onSuccess: (data) => {
          setThirdPartyAuthContextSuccess(
            data.fieldDescriptions,
            data.optionalFields,
            data.thirdPartyAuthContext,
          );
          // saving countryCode to registration context
          setBackendCountryCode(data.thirdPartyAuthContext.countryCode);
        },
        onError: () => {
          setThirdPartyAuthContextFailure();
        },
      });
      setFormStartTime(Date.now());
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formStartTime, queryParams, tpaHint, setThirdPartyAuthContextBegin]);

  // Handle backend validation errors from context
  useEffect(() => {
    if (backendValidations) {
      if (registrationEmbedded) {
        setTemporaryErrors(prevErrors => ({ ...prevErrors, ...backendValidations }));
      } else {
        setErrors(prevErrors => ({ ...prevErrors, ...backendValidations }));
      }
    }
  }, [backendValidations, registrationEmbedded]);

  useEffect(() => {
    if (registrationErrorCode) {
      setErrorCode(prevState => ({ type: registrationErrorCode, count: prevState.count + 1 }));
    }
  }, [registrationErrorCode]);

  useEffect(() => {
    if (registrationResult.success) {
      // This event is used by GTM
      sendTrackEvent('edx.bi.user.account.registered.client', {});

      // This is used by the "User Retention Rate Event" on GTM
      setCookie(getConfig().USER_RETENTION_COOKIE_NAME, true);
    }
  }, [registrationResult]);

  const handleOnChange = (event) => {
    const { name } = event.target;
    const value = event.target.type === 'checkbox' ? event.target.checked : event.target.value;
    if (backendRegistrationError[name]) {
      clearRegistrationBackendError(name);
    }
    // Clear context registration errors
    if (registrationError.errorCode) {
      setRegistrationError({});
    }
    setErrors(prevErrors => ({ ...prevErrors, [name]: '' }));
    // Update local state
    const newFormFields = { ...formFields, [name]: value };
    setFormFields(newFormFields);
    // Save to context for persistence across tab switches
    updateRegistrationFormData({
      formFields: newFormFields,
      errors,
      configurableFormFields,
    });
  };

  const handleErrorChange = (fieldName, error) => {
    if (registrationEmbedded) {
      setTemporaryErrors(prevErrors => ({
        ...prevErrors,
        [fieldName]: error,
      }));
      if (error === '' && errors[fieldName] !== '') {
        setErrors(prevErrors => ({
          ...prevErrors,
          [fieldName]: error,
        }));
      }
    } else {
      setErrors(prevErrors => ({
        ...prevErrors,
        [fieldName]: error,
      }));
    }
  };

  const registerUser = () => {
    const totalRegistrationTime = (Date.now() - formStartTime) / 1000;
    let payload = { ...formFields };

    if (currentProvider) {
      delete payload.password;
      payload.social_auth_provider = currentProvider;
    }
    if (flags.autoGeneratedUsernameEnabled) {
      delete payload.username;
    }

    // Validating form data before submitting
    const { isValid, fieldErrors, emailSuggestion } = isFormValid(
      payload,
      registrationEmbedded ? temporaryErrors : errors,
      configurableFormFields,
      fieldDescriptions,
      formatMessage,
    );
    setErrors({ ...fieldErrors });
    setEmailSuggestionContext(emailSuggestion.suggestion, emailSuggestion.type);

    // returning if not valid
    if (!isValid) {
      setErrorCode(prevState => ({ type: FORM_SUBMISSION_ERROR, count: prevState.count + 1 }));
      return;
    }

    payload = prepareRegistrationPayload(
      payload,
      configurableFormFields,
      flags.showMarketingEmailOptInCheckbox,
      totalRegistrationTime,
      queryParams);
    // making register call with React Query
    registrationMutation.mutate(payload);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    registerUser();
  };

  useEffect(() => {
    if (autoSubmitRegForm && userPipelineDataLoaded) {
      registerUser();
    }
  }, [autoSubmitRegForm, userPipelineDataLoaded]); // eslint-disable-line react-hooks/exhaustive-deps

  const renderForm = () => {
    if (institutionLogin) {
      return (
        <InstitutionLogistration
          secondaryProviders={secondaryProviders}
          headingTitle={formatMessage(messages['register.institution.login.page.title'])}
        />
      );
    }
    return (
      <>
        <Helmet>
          <title>{formatMessage(messages['register.page.title'], { siteName: getConfig().SITE_NAME })}</title>
        </Helmet>
        <RedirectLogistration
          host={host}
          authenticatedUser={registrationResult.authenticatedUser}
          success={registrationResult.success}
          redirectUrl={registrationResult.redirectUrl}
          finishAuthUrl={finishAuthUrl}
          optionalFields={optionalFields}
          registrationEmbedded={registrationEmbedded}
          redirectToProgressiveProfilingPage={
            getConfig().ENABLE_PROGRESSIVE_PROFILING_ON_AUTHN && !!Object.keys(optionalFields.fields).length
          }
        />
        {autoSubmitRegForm && !errorCode.type ? (
          <div className="mw-xs mt-5 text-center">
            <Spinner animation="border" variant="primary" id="tpa-spinner" />
          </div>
        ) : (
          <div
            className={classNames(
              'mw-xs mt-3',
              { 'w-100 m-auto pt-4 main-content': registrationEmbedded },
            )}
          >
            <ThirdPartyAuthAlert
              currentProvider={currentProvider}
              platformName={platformName}
              referrer={REGISTER_PAGE}
            />
            <RegistrationFailure
              errorCode={errorCode.type}
              failureCount={errorCode.count}
              context={{ provider: currentProvider, errorMessage: thirdPartyAuthErrorMessage }}
            />
            <Form id="registration-form" name="registration-form">
              <NameField
                name="name"
                value={formFields.name}
                shouldFetchUsernameSuggestions={!formFields.username.trim()}
                handleChange={handleOnChange}
                handleErrorChange={handleErrorChange}
                errorMessage={errors.name}
                helpText={[formatMessage(messages['help.text.name'])]}
                floatingLabel={formatMessage(messages['registration.fullname.label'])}
              />
              <EmailField
                name="email"
                value={formFields.email}
                confirmEmailValue={configurableFormFields?.confirm_email}
                handleErrorChange={handleErrorChange}
                handleChange={handleOnChange}
                errorMessage={errors.email}
                helpText={[formatMessage(messages['help.text.email'])]}
                floatingLabel={formatMessage(messages['registration.email.label'])}
              />
              {!flags.autoGeneratedUsernameEnabled && (
                <UsernameField
                  name="username"
                  spellCheck="false"
                  value={formFields.username}
                  handleChange={handleOnChange}
                  handleErrorChange={handleErrorChange}
                  errorMessage={errors.username}
                  helpText={[formatMessage(messages['help.text.username.1']), formatMessage(messages['help.text.username.2'])]}
                  floatingLabel={formatMessage(messages['registration.username.label'])}
                />
              )}
              {!currentProvider && (
                <PasswordField
                  name="password"
                  value={formFields.password}
                  handleChange={handleOnChange}
                  handleErrorChange={handleErrorChange}
                  errorMessage={errors.password}
                  floatingLabel={formatMessage(messages['registration.password.label'])}
                />
              )}
              <ConfigurableRegistrationForm
                email={formFields.email}
                fieldErrors={errors}
                formFields={configurableFormFields}
                setFieldErrors={registrationEmbedded ? setTemporaryErrors : setErrors}
                setFormFields={setConfigurableFormFields}
                autoSubmitRegisterForm={autoSubmitRegForm}
                fieldDescriptions={fieldDescriptions}
              />
              <StatefulButton
                id="register-user"
                name="register-user"
                type="submit"
                variant="brand"
                className="register-button mt-4 mb-4"
                state={submitState}
                labels={{
                  default: buttonLabel,
                  pending: '',
                }}
                onClick={handleSubmit}
                onMouseDown={(e) => e.preventDefault()}
              />
              {!registrationEmbedded && (
                <ThirdPartyAuth
                  currentProvider={currentProvider}
                  providers={providers}
                  secondaryProviders={secondaryProviders}
                  handleInstitutionLogin={handleInstitutionLogin}
                  thirdPartyAuthApiStatus={thirdPartyAuthApiStatus}
                />
              )}
            </Form>
          </div>
        )}
      </>
    );
  };

  if (tpaHint) {
    if (thirdPartyAuthApiStatus === PENDING_STATE) {
      return <Skeleton height={36} />;
    }
    const { provider, skipHintedLogin } = getTpaProvider(tpaHint, providers, secondaryProviders);
    if (skipHintedLogin) {
      window.location.href = getConfig().LMS_BASE_URL + provider.registerUrl;
      return null;
    }
    return provider ? <EnterpriseSSO provider={provider} /> : renderForm();
  }
  return (
    renderForm()
  );
};

RegistrationPage.propTypes = {
  institutionLogin: PropTypes.bool,
  handleInstitutionLogin: PropTypes.func,
};

RegistrationPage.defaultProps = {
  handleInstitutionLogin: null,
  institutionLogin: false,
};

export default RegistrationPage;
